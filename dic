#!/usr/bin/env ruby

require "colorize"

APP_NAME     = "dic"
ROOT         = "/usr/local/etc/#{APP_NAME}"
DOC_SHELF    = "/usr/local/etc/#{APP_NAME}/raw"
DOC_SHELF_P  = "/usr/local/etc/#{APP_NAME}/pages"

args = ARGV

def convert(file)
  lines = File.open(file, "r").map do |line|
    if is_link?(line) && !line.include?("http")
      tokens = line.split("](")
      tokens[0].chomp + "](" + tokens[1..-1].join.gsub(ROOT, "")
    elsif image_link_2?(line)   
      url = File.dirname(config["url"])
      puts url.yellow
      line.gsub(ROOT, "\"#{url}").split(" ").map do |t|
        unless /(.png|.jpg|.gif|.JPG)/.match(t).nil?
          t + "\""
        else
          t
        end
      end.join(" ")
    else  
      line
    end
  end
  lines.compact.each do |line|
  end
  f = File.open(File.join(DOC_SHELF_P, File.basename(file)), "w")
  lines.compact.each do |line|
    f.puts line
  end
end

def config
  confs = File.open("#{ROOT}/.config", "r").map do |line|
    line.split(" ")
  end.flatten
  Hash[*confs]
end

def edit(file_name)
   name = File.basename(file_name).gsub('.md','')
   puts "\n#{name.green}\n\n"
   print "[Enter: open, v: vim, l: links c: cat /: search w: web] "
   opt = $stdin.gets.chomp
   case opt
   when "w"
     url = config["url"].gsub("$", name)
     system "open #{url}"
   when "c"
     system "cat #{file_name}"
   when "v"
     system "vim #{file_name}"
   when "l"
     links file_name
   when "q"  
     abort
   else
     if opt.start_with?("/")
      opt = opt.gsub("/", "")
      unless opt
        print "[term:] "
        opt = $stdin.gets.chomp
      end  
      opt = opt.split(" ")
      edit("#{DOC_SHELF}/#{show_and_get_file(all_files, opt)}.md")
     end  
     system "macdown #{file_name}"
   end
   edit file_name
end

def option?(arg)
  arg.start_with?("-")
end

def key_words
  ARGV.select { |arg| !option?(arg) }
end

def options
  ARGV.select { |arg| option?(arg) }
end

def files_contains_keywords(files, key_words)
  files.select do |file|
    key_words.select{|kw| file.include?(kw)}.size == key_words.size
  end
end

def num?(num)
  num =~ /\A[-+]?[0-9]*\.?[0-9]+\Z/
end

def get_files(files, key_words)
  (files.size == 0 ? all_files : files_contains_keywords(files, key_words))
    .uniq
    .select{|x| x != "images"}
end

def show_and_get_file(files, key_words, option=nil)
  files = get_files(files, key_words)
  return key_words.join("_") if files.size == 0
  puts
  files.each_with_index do |file, i|
    puts "[#{i}] #{file}"
  end
  puts
  unless option
    print "[(index|keywords)] "
    option = $stdin.gets.chomp
  end  
  if num?(option)
    files[option.to_i] 
  elsif option == "q"
    abort
  else
    show_and_get_file(files, option.split(" "))
  end
end

def parse_link(link)
  link = link.split("](")[1].gsub(')','')
  link.split(" ").select{|x| x.start_with?("http") || x.start_with?("/")}.first
rescue
  abort "link parse failure: #{link}"
end

def image_link_2?(line)
  line.include?("<img src=")
end

def image_link?(line)
  !/\[*\]/.match(line).nil? && line.strip.start_with?("!")
end

def is_link?(line)
  !/\[*\]/.match(line).nil? && !line.strip.start_with?("!")
end

def links(file)
  links = File.open(file, "r").select do |line|
    is_link? line
  end
  puts
  links.each_with_index do |link, i|
    puts "[#{i}] #{link.split("](").first.gsub('[','')}"
  end
  print "[which? none:q] "
  opt = $stdin.gets.chomp.downcase
  abort if opt == "q"

  link = parse_link(links[opt.to_i])
  if link.include?("http")
    system "open #{link}"
  else
    target = "#{DOC_SHELF}/#{link}.md"
    if File.exist?(target)
      edit target
    else
      puts "\ninvalid link: #{target}\n\n"
    end
  end
end

def all_files
  Dir["#{DOC_SHELF}/*"].map{|file| File.basename(file).gsub(".md","")}
end

def set_image
  print "[name:] "  
  name = $stdin.gets.chomp
  abort "you need name." unless name
  files = key_words.select{|kw| File.exist?(kw)}
  abort "you need image file." if files.size == 0
  file = files.first
  ARGV.delete(file)
  extension = file.split(".").last
  system "mkdir -p #{DOC_SHELF}/images"
  system "mkdir -p #{DOC_SHELF_P}/images"
  target    = "#{DOC_SHELF_P}/images/#{name}.#{extension}".gsub("//","/")
  target2   = "#{DOC_SHELF}/images/#{name}.#{extension}".gsub("//","/")
  system "cp #{file} #{target}"
  system "cp #{target} #{target2}"
  markdown = "<img src=\"#{target}\" width=152>"
  system("echo \"#{markdown}\" | pbcopy")
  puts "\n#{markdown}\n\n"
end  

case options.first
when "-h", "--help"
  puts
  puts "#{APP_NAME} -n [word] ... make new article"
  puts "#{APP_NAME} [word]    ... edit article"
  puts "#{APP_NAME} -d [word] ... remove article"
  puts "#{APP_NAME} -c        ... convert"
  puts "#{APP_NAME} -i [image file path] ... add image rsc and markdown to the clipboard"
  puts
when "-d" 
  term = show_and_get_file(all_files, key_words)
  print "okay to delete [#{term}] ? [Y/n]: "
  system("rm #{DOC_SHELF}/#{term}.md") if $stdin.gets.chomp.downcase == "y"
when "-i" # image
  set_image
when "-c"  
  Dir["#{DOC_SHELF}/*"].each do |file|
    convert file
  end
else
  system("mkdir -p #{DOC_SHELF}") unless File.directory?(DOC_SHELF)
  file_name = "#{DOC_SHELF}/#{key_words.join('_')}.md"
  puts file_name
  if options.include?("-n") || File.exist?(file_name)
    edit(file_name)
  else
    edit("#{DOC_SHELF}/#{show_and_get_file(all_files, key_words)}.md")
  end  
end




