#!/usr/bin/env ruby

require "colorize"
require "/usr/local/lib/vol/util.rb"

APP_NAME     = "vol"
ROOT         = "/usr/local/etc/#{APP_NAME}"
DOC_SHELF    = "/usr/local/etc/#{APP_NAME}/raw"
DOC_SHELF_P  = "/usr/local/etc/#{APP_NAME}/pages"

args = ARGV

def md_image_link(line, root, shelf)
  tokens = line.split("](")
  ("!" + tokens[0].chomp + "](" + tokens[1..-1].join.gsub(root, ""))
    .gsub(shelf + "/", "").gsub("!!","!")
end

def pict_link?(line)
 Lib::Util.image_link?(line) && !line.include?("http")
end

def convert(file)
  rewrite(
    file:  file,
    lines: File.open(file, "r").map do |line|
             pict_link?(line) ? md_image_link(line, ROOT, DOC_SHELF) : line
           end
  )
end

def rewrite(file:, lines:)
  def trim_local_urls(line)
    line.gsub(DOC_SHELF + "/", "")
        .gsub(DOC_SHELF_P + "/", "")
        .gsub(ROOT + "/", "")
  end
  f = File.open(File.join(DOC_SHELF_P, File.basename(file)), "w")
  lines.compact.each do |line|
    f.puts trim_local_urls(line)
  end
  f.close
end

def config
  confs = File.open("#{ROOT}/.config", "r").map do |line|
    line.split(" ")
  end.flatten
  Hash[*confs]
end

def bring(name, file_name)
  another_page =
    get_file(all_files, Lib::Util.ask("page:").split(" "))
  another_page_path = File.join(DOC_SHELF, another_page)  
  unless File.exist?(another_page_path)
    system "touch #{another_page_path}"                
  end
  Lib::Util.push_as_link(DOC_SHELF, another_page, name) 
  another_page
end

def push(name, file_name, dest = nil)
  dest ||= get_file(all_files, Lib::Util.ask("dest:").split(" "))
  dest_file = File.join(DOC_SHELF, dest + ".md")
  unless File.exist?(dest_file)
    system "touch #{dest_file}"                
  end
  Lib::Util.push_as_link(DOC_SHELF, name, dest) 
end

def edit(file_name)
   name = File.basename(file_name).gsub('.md','')
   puts
   print "[New:] ".magenta unless File.exist?(file_name)
   puts "#{name.green}\n\n"
   print "[m: markup, v: vim, l: links]\n" + 
         "[c: cat /: search h: head d: delete]\n" +
         "[w: web u:update + open uu: update]\n" +
         "[p: push to another page]\n" + 
         "[b: bring in another page]\n" + 
         "[which?] "
         
   opt = $stdin.gets.chomp
   case opt
   when "h"
     puts "\n=============== head =================".green
     system "head #{file_name}"
     puts "=========================================".green
     puts 
   when "bp", "pb"  
     push(name, file_name, bring(name, file_name))
   when "b"  
     bring(name, file_name)
   when "p"
     push(name, file_name)
   when "u"
     update_wiki
     url = config["url"].gsub("$", name)
     system "open #{url}"
   when "uu"  
     update_wiki
   when "w"
     url = config["url"].gsub("$", name)
     system "open #{url}"
   when "c"
     system "cat #{file_name}"
   when "d"  
     system "rm #{file_name}"
     puts "REMOVED: #{file_name}".red
   when "v"
     system "vim #{file_name}"
   when "l"
     links file_name
   when "q"  
     abort
   when "m"  
     system "macdown #{file_name}"
   else
     if opt.start_with?("/")
      opt = opt.gsub("/", "")
      unless opt
        print "[term:] "
        opt = $stdin.gets.chomp
      end  
      opt = opt.split(" ")
      edit("#{DOC_SHELF}/#{get_file(all_files, opt)}.md")
       system "macdown #{file_name}"
     end  
   end
   edit file_name
end

def key_words
  ARGV.select { |arg| !Lib::Util::option?(arg) }
end

def options
  ARGV.select { |arg| Lib::Util::option?(arg) }
end

def get_file(files, key_words, option=nil)
  files = Lib::Util.get_files(files, key_words)
  return key_words.join("_") if files.size == 0
  return files.first         if files.size == 1
  Lib::Util.show files
  option ||= Lib::Util.ask("index|keywords")
  Lib::Util.num?(option) ? files[option.to_i] : get_file(files, option.split(" "))
end

def parse_link(link)
  link = link.split("](")[1].gsub(')','')
  link.split(" ").select{|x| x.start_with?("http") || x.start_with?("/")}.first
rescue
  abort "link parse failure: #{link}"
end

def links_sub(links)
  opt = 0
  if links.size > 1
    puts
    links.each_with_index do |link, i|
      title = link.split("](").first.gsub('[','').cyan
      puts "[#{i.to_s.magenta}] #{title}"
    end
    opt = Lib::Util.ask("which? none:q")
    unless Lib::Util.num?(opt)
      return links_sub(links.select{|link| link.include?(opt) })
    end
  end

  link = parse_link(links[opt.to_i])
  link ||= links[opt.to_i]
end

def links(file)
  links = File.open(file, "r").select do |line|
    Lib::Util.is_link? line
  end
  link = links_sub(links)
  if http?(link)
    system "open #{link}"
  else
    if Lib::Util.markdown_link_format?(link)
       link = Lib::Util.remove_markdown(link)      
    end
    target = "#{DOC_SHELF}/#{File.basename(link.gsub('.md', '')).chomp}.md"
    if File.exist?(target)
      edit target
    else
      puts "\ninvalid link: #{target}\n\n"
    end
  end
end

def http?(link)
  link.include?("http")
end

def all_files
  Dir["#{DOC_SHELF}/*"].map{|file| File.basename(file).gsub(".md","")}
end

def mkdir_docshelfs
  system "mkdir -p #{DOC_SHELF}/images"
  system "mkdir -p #{DOC_SHELF_P}/images"
end

def image_path(root, name, extension)
  "#{root}/images/#{name}.#{extension}".gsub("//","/")
end

def fit(path)
  path.gsub(" ", "\\ ")
end

def extract_files(files)
  files.select{|file| File.exist?(file)}
end

def stop(message, cond)
  abort message if cond
end

def inter(message)
  print message
  $stdin.gets.chomp
end

def set_image
  name = inter "[name:] "  
  stop "you need name", !name 
  files = extract_files(key_words)
  stop "you need image file.", files.size == 0
  file = fit(files.first)
  ARGV.delete(file)
  extension = file.split(".").last

  mkdir_docshelfs 

  target  = fit(image_path(DOC_SHELF_P, name, extension))

  def xxx(target)
    File.join(
      File.dirname(target), 
      "#{Time.now.to_f.to_i}_" + File.basename(target)
    )  
  end

  if File.exist?(target)
    target = xxx(target)
    name   = xxx(name)
  end

  def validate_file(file)
    unless File.exist?(file)
      abort "FILE ABSENT: #{file}".red
    end
  end

  Lib::Util.copy file, target

  validate_file target
  fin_dest = fit(image_path(DOC_SHELF, name, extension))

  Lib::Util.copy target, fin_dest

  validate_file fin_dest

  markdown = "![image](#{target})"
  system("echo \"#{markdown}\" | pbcopy")
  puts "\n#{markdown}\n\n"
end  

def update_wiki
  do_convert
  system "cd #{ROOT};git add #{ROOT};git commit -m \"page updated\";git push origin master"
end

def do_convert
  Dir["#{DOC_SHELF}/*"].each do |file|
    convert(file) if File.file?(file)
  end
end

case options.first
when "-u"
  update_wiki
when "-h", "--help"
  puts
  puts "#{APP_NAME} -n [word] ... make new article"
  puts "#{APP_NAME} [word]    ... edit article"
  puts "#{APP_NAME} -d [word] ... remove article"
  puts "#{APP_NAME} -c        ... convert"
  puts "#{APP_NAME} -u        ... update web page"
  puts "#{APP_NAME} -i [image file path] ... add image rsc and markdown to the clipboard"
  puts
when "-d" 
  term = get_file(all_files, key_words)
  print "okay to delete [#{term}] ? [Y/n]: "
  system("rm #{DOC_SHELF}/#{term}.md") if $stdin.gets.chomp.downcase == "y"
when "-i" # image
  set_image
when "-c"  
  do_convert
else
  system("mkdir -p #{DOC_SHELF}") unless File.directory?(DOC_SHELF)
  file_name = "#{DOC_SHELF}/#{key_words.join('_')}.md"
  if options.include?("-n") || File.exist?(file_name)
    edit(file_name)
  else
    edit "#{DOC_SHELF}/#{get_file(all_files, key_words)}.md"
  end  
end




