#!/usr/bin/env ruby

require "colorize"
require "fileutils"
require "./app/lib/location.rb"
require "./app/lib/wiki.rb"
require "./app/lib/args.rb"
require "./app/lib/resource/base.rb"
require "./app/lib/resource/image.rb"

class Main
  attr_reader :option

  def initialize(args)
    @args     = Args.new(args)
    @location = Location.new
    @wiki     = Wiki.new(@location)
    @resource = Resource::Base.new(resources: @args.values)
    @option   = @args.options.first
    @original_articles  = @wiki.original_articles
    @formatted_articles = @wiki.formatted_articles
  end

  def execute
    case @option
    when "-i"
      @resource.attach
    when "-u"  
      @wiki.save
    when "-g"
      grep
    when "-n"  
      @wiki.create(@args.values) 
    else
      enlist(@original_articles, @formatted_articles, nil)
    end
  end    

  def dont_have(text)
    return true if @args.negations.size == 0
    @args.negations.select {|neg| text.include?(neg) }.size == 0
  end

  def text_matches_pattern?(file, regex)
    match?(file_read(file), regex)
  end

  def base_name(file)
    file.gsub("#{raw}/", "").gsub(".md", "")
  end

  def show_match_details(file, regex)
    puts "\n[file] " + base_name(file) 
    file_read_lines(file).each do |line|
      !(regex =~ line) || puts("... #{paint(line, @args.values)} ...\n")
    end  
  end

  def regex(args = nil)
    Regexp.new((args || @args.values).join(".+"))
  end

  def grep(args = nil)
    _regex = regex(args)
    puts "regex: #{_regex}".yellow
    files = md_files_raw_all
      .select { |file| text_matches_pattern?(file, _regex) }
    files.each { |file| show_match_details(file, _regex)   }

    files
  end

  def paint(text, key_words = nil)
    (key_words || @args.values).each do |key_word|
      text = text.gsub(key_word, key_word.green)
    end
    text
  end

  def link?(line)
    /^[\s\-]*\[[^\[\]]*\]\([^\(\)]+\)/ =~ line || /http[s]*:\/\// =~ line
  end

  def links(file)
    file_read_lines(file).select { |line| link?(line) }
  end

  def match?(text, args = nil)
    args ||= regex
    regex = (args.class == Array) ? regex(args) : args
    regex =~ text && dont_have(text)
  end

  def ask_input(msg = "[,{@}pyna/vwu]> ")
    print msg
    $stdin.gets.chomp
  end

  def get_files(files)
    files.size == 0 ? @original_articles : files
  end

  def config
    confs = File.open(@location.config, "r").map do |line|
      line.split(" ")
    end.flatten
    Hash[*confs]
  end

  def open_url(input, files)
    url = config["url"]
            .gsub("$", target_file(input, files))
            .gsub(raw, "")
            .gsub("md.md", "md")
    system "open #{url}"
  end

  def enlist_links(file, links = [])
    return if file.nil?
    if links.size == 0
      links = file_read_lines(file)
        .select { |line| link?(line) }
        .map    { |line|
          /(\/usr\/local\/|http)[^\s\)\(]+/.match(line.strip).to_s.split(" ").first 
        }
        .compact
        .uniq
    end    
    puts "#{File.basename(file)}\n".cyan
    links.each_with_index { |l, i| puts "[#{i + 1}] #{l}" }
    input = ask_input(",{@}p>").strip
    abort if input == "q".downcase.strip

    if /^[\,\s]+$/ =~ input
      puts "#{input.size} < #{links.size}".magenta
      input = "," unless input.size - 1 < links.size
      system "open #{links[input.size - 1]}"
    elsif /^[p\s]+$/ =~ input  
    else
      r = regex(input.split(" "))
      enlist_links(file, links.select{ |l| r =~ l } )    
    end
  end

  #
  # XXX add function
  #
  def chapters(file)
    file_read_lines(file)
      .select { |line| /^[#]+/ =~ line }
      .map    { |line| line.gsub("#", "  ") }
  end

  def read_chapter(file, title)
    flag = 0
    file_read_lines(file).each do |line|
      if flag == 1
        return if /^[#]+/ =~ line
        puts line.magenta
      end
      flag = 1 if line.include?(title.strip)
    end
  end

  def c(input, files)
    puts
    file = target_file(input, files)
    _chapters = chapters(file)
    _chapters.each_with_index do |chapter, i|
      puts "#{i}: #{chapter.green}"
    end
    puts
    input = ask_input("[chapter{@}]: ").downcase.to_i
    read_chapter(file,  _chapters[input])
  end

  def target_file(input, files)
    file_index = input.strip.size - 1
    file_index = 0 unless file_index < files.size
    files[file_index]
  end

  def main_op(input, files, prev_files, args)
    if /^[c\s]+/ =~ input
      c(input, files)
    elsif /^[+\s]+/ =~ input # former pb
      
    elsif /^[l\s]+/ =~ input
      enlist_links(target_file(input, files))
    elsif /^[g\s]+/ =~ input
      files = grep(input[1..-1].strip.split(" ")); args = []
    elsif /^[u\s]+$/ =~ input
      update_git_repository
    elsif /^[w\s]+$/ =~ input
      open_url(input, files)
    elsif /^q\s*$/ =~ input
      abort
    elsif /^[\/]/ =~ input
      files = []; args  = input[1..-1].split(" ")
    elsif /^[v]+\s*$/ =~ input
      @wiki.edit(files, input.strip.size)
    elsif /^[v]+\s*\d+$/ =~ input
      @wiki.edit(files, input.gsub("v", "").strip.to_i)
    elsif /^[a\s]+$/ =~ input
      files = []; args  = []
    elsif /^[p\s]+$/ =~ input  
      files = prev_files
    elsif /^[\d\s]+$/ =~ input
      files = [files[input.to_i - 1]]
    elsif /^[\,\s]+$/ =~ input 
      files = [files[input.size - 1]]
    elsif /^y[\s]*/ =~ input
      files.each do |file|
        mutual_link(file, input.gsub("y", "").strip.split(" "))
      end  
    elsif /^\w+$/ =~ input
      args = input.split(" ")
    elsif input.include?("n ")  
      @wiki.create(input[2..-1])
    end 
    [files, prev_files, args]
  end

  def enlist(files, prev_files, args)
    files = get_files(files).select { |file| match?(file, args) }
    files.each_with_index { |file, i|
      print "[#{i+1}] "
      puts paint(base_name(file), args)
    }

    files, prev_files, args = main_op(ask_input, files, prev_files, args)
    enlist(files, prev_files, args)
  end

  def escape(text)
    text.gsub(" ", "\\ ")
  end

  def disp_files(files)
    files.each_with_index { |c, i| puts "[#{i + 1}] #{base_name(c)}" }
  end

  def files_match_pattern(pattern)
    md_files_raw_all.select { |article|
      pattern =~ article  
    }
  end

  def regex_args_stdin_split_with_space
    print "?/ > "
    input = $stdin.gets.chomp
    abort if quit?(input)
    args = input.split(" ")
    args.size > 0 ? regex(args) : /^.*$/
  end

  def number?(value)
    /^\d+$/ =~ value 
  end

  def quit?(value)
    /^[q\s]+$/ =~ value
  end

  def insert_link(file1, file2)
    f = File.open(file2, "a")
    base = base_name(file1)
    f.puts "- [#{base}](#{base}.md)"  
    f.close
  end

  def mutual_link(your_current_file, args = [])
    files = files_match_pattern(
              args.size > 0 ? regex(args) : regex_args_stdin_split_with_space
            )
    files.delete(your_current_file)
            
    disp_files(files)

    if files.size == 0
      puts "file not found".red
        mutual_link(your_current_file, [])
    else
      print "{@}> "
      input = $stdin.gets.chomp
      if number?(input)
        size = 1 unless size < files.size
        file = files[size - 1]
        insert_link(file, your_current_file)
        insert_link(your_current_file, file)
        puts "\n[added!]\n".green
      elsif quit?(input) 
      else
        mutual_link(your_current_file, input.split(" "))
      end
    end  
  end
end

Main.new(ARGV).execute


