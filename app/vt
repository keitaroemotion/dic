#!/usr/bin/env ruby

require "colorize"
require "fileutils"
require "./app/lib/location.rb"
require "./app/lib/wiki.rb"
require "./app/lib/args.rb"
require "./app/lib/resource/base.rb"
require "./app/lib/resource/image.rb"
require "./app/lib/url.rb"

#
# Interface Segregatin Principle: 
#  this is the class which used to be boilerplate and going to
#  be refactored from. the classes under app/lib/**/* are 
#  ENCAPSULATED classes for the ISP realization.
#  it is on the way.
#
class Main
  attr_reader :option

  def initialize(args)
    @args     = Args.new(args)
    @location = Location.new
    @wiki     = Wiki.new(@location)
    @resource = Resource::Base.new(resources: @args.values)
    @option   = @args.options.first
    @original_articles  = @wiki.original_articles
    @formatted_articles = @wiki.formatted_articles
  end

  def execute
    case @option
    when "-i"
      @resource.attach
    when "-u"  
      @wiki.save
    when "-g"
      grep
    when "-n"  
      @wiki.create(@args.values) 
    else
      enlist(@original_articles, @formatted_articles, nil)
    end
  end    

  def text_matches_pattern?(file, regex)
    match?(file_read(file), regex)
  end

  def base_name(file)
    file.gsub("#{@location.raw}/", "").gsub(".md", "")
  end

  def grep(args = nil)
    files = md_files_raw_all
      .select { |file| text_matches_pattern?(file, _regex) }
    files.each { |file| Regex.new(args).list_matches(file)   }

    files
  end

  def paint(text, key_words = nil)
    (key_words || @args.values).each do |key_word|
      text = text.gsub(key_word, key_word.green)
    end
    text
  end

  def get_files(files)
    files.size == 0 ? @original_articles : files
  end

  def config
    confs = File.open(@location.config, "r").map do |line|
      line.split(" ")
    end.flatten
    Hash[*confs]
  end

  #
  # XXX add function
  #
  def chapters(file)
    file_read_lines(file)
      .select { |line| /^[#]+/ =~ line }
      .map    { |line| line.gsub("#", "  ") }
  end

  def read_chapter(file, title)
    flag = 0
    file_read_lines(file).each do |line|
      if flag == 1
        return if /^[#]+/ =~ line
        puts line.magenta
      end
      flag = 1 if line.include?(title.strip)
    end
  end

  def c(input, files)
    puts
    file = URL.new(files, input).file
    _chapters = chapters(file)
    _chapters.each_with_index do |chapter, i|
      puts "#{i}: #{chapter.green}"
    end
    puts
    input = ask_input("[chapter{@}]: ").downcase.to_i
    read_chapter(file,  _chapters[input])
  end

  def main_op(input, files, prev_files, args)
    if /^[c\s]+/ =~ input
      c(input, files)
    elsif /^[+\s]+/ =~ input # former pb
      
    elsif /^[l\s]+/ =~ input
      URL.new(files).show
    elsif /^[g\s]+/ =~ input
      files = grep(input[1..-1].strip.split(" ")); args = []
    elsif /^[u\s]+$/ =~ input
      update_git_repository
    elsif /^[w\s]+$/ =~ input
      open_url(input, files)
    elsif /^q\s*$/ =~ input
      abort
    elsif /^[\/]/ =~ input
      files = []; args  = input[1..-1].split(" ")
    elsif /^[v]+\s*$/ =~ input
      @wiki.edit(files, input.strip.size)
    elsif /^[v]+\s*\d+$/ =~ input
      @wiki.edit(files, input.gsub("v", "").strip.to_i)
    elsif /^[a\s]+$/ =~ input
      files = []; args  = []
    elsif /^[p\s]+$/ =~ input  
      files = prev_files
    elsif /^[\d\s]+$/ =~ input
      files = [files[input.to_i - 1]]
    elsif /^[\,\s]+$/ =~ input 
      files = [files[input.size - 1]]
    elsif /^y[\s]*/ =~ input
      files.each do |file|
        mutual_link(file, input.gsub("y", "").strip.split(" "))
      end  
    elsif /^\w+$/ =~ input
      args = input.split(" ")
    elsif input.include?("n ")  
      @wiki.create(input[2..-1])
    end 
    [files, prev_files, args]
  end

  def enlist(files, prev_files, args)
    files = get_files(files).select { |file| match?(file, args) }
    files.each_with_index { |file, i|
      print "[#{i+1}] "
      puts paint(base_name(file), args)
    }

    files, prev_files, args = main_op(Terminal.ask_input, files, prev_files, args)
    enlist(files, prev_files, args)
  end

  def escape(text)
    text.gsub(" ", "\\ ")
  end

  def disp_files(files)
    files.each_with_index { |c, i| puts "[#{i + 1}] #{base_name(c)}" }
  end

  def files_match_pattern(pattern)
    md_files_raw_all.select { |article|
      pattern =~ article  
    }
  end

  def number?(value)
    /^\d+$/ =~ value 
  end

  def quit?(value)
    /^[q\s]+$/ =~ value
  end
end

Main.new(ARGV).execute


